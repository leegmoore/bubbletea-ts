import { mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';

const repoRoot = resolve(process.cwd());
const goSourcePath = join(repoRoot, 'key.go');
const targetPath = join(repoRoot, 'packages/tests/src/key/fixtures/goSequences.ts');
const runtimeTargetPath = join(repoRoot, 'packages/tea/src/internal/generated/goSequences.ts');

const source = readFileSync(goSourcePath, 'utf8');
const marker = 'var sequences = map[string]Key{';
const startIndex = source.indexOf(marker);
if (startIndex === -1) {
  throw new Error('Could not locate sequences map in key.go');
}

const firstBraceIndex = source.indexOf('{', startIndex + marker.length - 1);
if (firstBraceIndex === -1) {
  throw new Error('Could not locate opening brace for sequences map');
}

let depth = 0;
let endIndex = -1;
for (let i = firstBraceIndex; i < source.length; i++) {
  const char = source[i];
  if (char === '{') {
    depth++;
  } else if (char === '}') {
    depth--;
    if (depth === 0) {
      endIndex = i;
      break;
    }
  }
}

if (endIndex === -1) {
  throw new Error('Could not locate closing brace for sequences map');
}

const mapBody = source.slice(firstBraceIndex + 1, endIndex);
const lines = mapBody.split(/\r?\n/);

const entries = [];
let buffer = '';
let inlineComments = [];

const pushPendingEntry = () => {
  if (!buffer.trim()) {
    buffer = '';
    inlineComments = [];
    return;
  }
  const raw = buffer.trim();
  entries.push({ kind: 'entry', raw, comment: inlineComments.join(' ').trim() || null });
  buffer = '';
  inlineComments = [];
};

for (const line of lines) {
  const trimmedRight = line.replace(/\s+$/, '');
  const trimmed = trimmedRight.trim();
  if (!trimmed) {
    continue;
  }

  const commentIndex = trimmedRight.indexOf('//');
  let codePart = trimmedRight;
  let inlineComment = '';
  if (commentIndex !== -1) {
    inlineComment = trimmedRight.slice(commentIndex + 2).trim();
    codePart = trimmedRight.slice(0, commentIndex).trimEnd();
  }

  if (!codePart) {
    entries.push({ kind: 'comment', text: inlineComment });
    continue;
  }

  buffer += `${codePart}\n`;
  if (inlineComment) {
    inlineComments.push(inlineComment);
  }

  const normalized = codePart.trimEnd();
  if (normalized.endsWith('},') || normalized.endsWith('}')) {
    pushPendingEntry();
  }
}

const decodeGoStringLiteral = (literal) => {
  const replaced = literal.replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) => {
    const padded = hex.padStart(2, '0').toLowerCase();
    return `\\u00${padded}`;
  });
  const escaped = replaced.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return JSON.parse(`"${escaped}"`);
};

const encodeTsString = (value) => {
  let result = '"';
  for (const char of value) {
    const codePoint = char.codePointAt(0);
    if (codePoint === undefined) {
      continue;
    }
    switch (char) {
      case '"':
        result += '\\"';
        break;
      case '\\\\':
        result += '\\\\';
        break;
      case '\n':
        result += '\\\\n';
        break;
      case '\r':
        result += '\\\\r';
        break;
      case '\t':
        result += '\\\\t';
        break;
      default: {
        if (codePoint < 0x20 || codePoint === 0x7f) {
          result += `\\\\x${codePoint.toString(16).padStart(2, '0')}`;
        } else if (codePoint > 0xffff) {
          result += `\\\\u{${codePoint.toString(16)}}`;
        } else if (codePoint > 0x7e) {
          result += `\\\\u${codePoint.toString(16).padStart(4, '0')}`;
        } else {
          result += char;
        }
        break;
      }
    }
  }
  result += '"';
  return result;
};

const parseEntry = (raw) => {
  const match = raw.match(/"([^\"]+)"\s*:\s*{([^}]*)}/s);
  if (!match) {
    throw new Error(`Unable to parse entry: ${raw}`);
  }
  const [, keyLiteral, body] = match;
  const decodedKey = decodeGoStringLiteral(keyLiteral);
  const props = [];
  for (const piece of body.split(',')) {
    const part = piece.trim();
    if (!part) {
      continue;
    }
    const [fieldKey, fieldValue] = part.split(':').map((segment) => segment.trim());
    if (!fieldKey || !fieldValue) {
      continue;
    }
    if (fieldKey === 'Type') {
      props.push(`type: KeyType.${fieldValue}`);
    } else if (fieldKey === 'Alt') {
      props.push(`alt: ${fieldValue}`);
    } else {
      throw new Error(`Unknown field "${fieldKey}" in entry: ${raw}`);
    }
  }
  return { key: decodedKey, props };
};

const buildOutputLines = (importPath) => {
  const lines = [];
  lines.push('// This file is auto-generated by scripts/generate-key-sequences.mjs.');
  lines.push('// Do not edit by hand; update the Go sequences map and re-run the script.');
  lines.push(`import { KeyType } from '${importPath}';`);
  lines.push('');
  lines.push('export interface SequenceEntry {');
  lines.push('  readonly type: KeyType;');
  lines.push('  readonly alt?: boolean;');
  lines.push('}');
  lines.push('');
  lines.push('export const goSequences: Record<string, SequenceEntry> = {');

  for (const entry of entries) {
    if (entry.kind === 'comment') {
      lines.push(`  // ${entry.text}`);
      continue;
    }
    const { key, props } = parseEntry(entry.raw);
    const propText = props.join(', ');
    const commentSuffix = entry.comment ? ` // ${entry.comment}` : '';
    const literal = encodeTsString(key);
    lines.push(`  ${literal}: { ${propText} },${commentSuffix}`);
  }

  lines.push('};');
  lines.push('');
  return lines;
};

const outputs = [
  { path: targetPath, importPath: "@bubbletea/tea" },
  { path: runtimeTargetPath, importPath: '../../key' }
];

for (const { path, importPath } of outputs) {
  const lines = buildOutputLines(importPath);
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, `${lines.join('\n')}\n`);
}
